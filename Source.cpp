#include <iostream>
#include <locale.h>

using namespace std;

class MultiSet 
{
private:
    int* elements; // Массив элементов
    size_t size;   // Текущий размер множества
    size_t capacity; // Емкость массива

    static const int RUN = 32;

    /**
 * @brief Обеспечивает достаточную емкость массива для хранения элементов.
 *
 * Функция проверяет, достаточно ли текущей емкости массива `elements` для добавления новых элементов.
 * Если текущее количество элементов (`size`) равно или превышает емкость (`capacity`),
 * массив расширяется в два раза. При этом элементы из старого массива копируются
 * в новый, а старый массив освобождается.
 *
 * @note Если не удается выделить память для нового массива, программа завершает выполнение с ошибкой.
 */
    void ensure_capacity() 
    {
        // Проверяем, нужно ли увеличивать емкость
        if (size >= capacity)
        {
            // Увеличиваем емкость в два раза
            capacity *= 2;

            // Выделяем новый массив с увеличенной емкостью
            int* new_elements = new int[capacity];
            if (!new_elements)
            {
                cerr << "Ошибка выделения памяти!" << endl;
                exit(1);
            }

            // Копируем элементы из старого массива в новый
            for (size_t i = 0; i < size; ++i) 
            {
                new_elements[i] = elements[i];
            }

            // Освобождаем старый массив
            delete[] elements;

            // Обновляем указатель на новый массив
            elements = new_elements;
        }
    }


    void insertion_sort(int* arr, size_t left, size_t right) 
    {
        for (size_t i = left + 1; i <= right; i++)
        {
            int temp = arr[i];
            size_t j = i - 1;
            while (j >= left && arr[j] > temp)
            {
                arr[j + 1] = arr[j];
                if (j-- == 0) break; // Защита от переполнения
            }
            arr[j + 1] = temp;
        }
    }

    void merge(int* arr, size_t l, size_t m, size_t r) 
    {
        size_t len1 = m - l + 1, len2 = r - m;
        int* left = new int[len1];
        int* right = new int[len2];

        for (size_t i = 0; i < len1; i++) left[i] = arr[l + i];
        for (size_t i = 0; i < len2; i++) right[i] = arr[m + 1 + i];

        size_t i = 0, j = 0, k = l;
        while (i < len1 && j < len2) 
        {
            if (left[i] <= right[j]) 
            {
                arr[k++] = left[i++];
            }
            else 
            {
                arr[k++] = right[j++];
            }
        }

        while (i < len1) arr[k++] = left[i++];
        while (j < len2) arr[k++] = right[j++];

        delete[] left;
        delete[] right;
    }

    void timsort() 
    {
        for (size_t i = 0; i < size; i += RUN)
        {
            insertion_sort(elements, i, (i + RUN - 1 < size ? i + RUN - 1 : size - 1));
        }

        for (size_t width = RUN; width < size; width *= 2) 
        {
            for (size_t left = 0; left < size; left += 2 * width)
            {
                size_t mid = left + width - 1;
                size_t right = (left + 2 * width - 1 < size ? left + 2 * width - 1 : size - 1);

                if (mid < right)
                {
                    merge(elements, left, mid, right);
                }
            }
        }
    }


    /**
 * @brief Подсчитывает частоту вхождения каждого элемента множества и находит максимальный элемент.
 *
 * Алгоритм:
 * 1. Проходит по всем элементам множества.
 * 2. Увеличивает значение частоты в массиве `freq` на индексе, соответствующем значению элемента.
 * 3. Если текущий элемент больше `max_elem`, обновляет `max_elem`.
 *
 * @param freq Массив частот, где freq[i] хранит количество вхождений элемента i. Должен быть инициализирован нулями.
 * @param max_elem Ссылка на переменную, в которой будет сохранён максимальный элемент множества.
 */
    void count_frequencies(int* freq, int& max_elem) const
    {
        for (size_t i = 0; i < size; ++i)
        {
            freq[elements[i]]++;
            if (elements[i] > max_elem) max_elem = elements[i];
        }
    }

public:

    /**
 * @brief Конструктор по умолчанию. Инициализирует пустое мультимножество.
 *
 * Алгоритм:
 * 1. Устанавливает размер множества (size) равным 0.
 * 2. Устанавливает начальную емкость множества (capacity) равной 10.
 * 3. Выделяет память для массива элементов `elements`.
 * 4. Проверяет успешность выделения памяти. Если память не выделена, завершает выполнение программы с сообщением об ошибке.
 */
    MultiSet()
    {
        size = 0; // Начальный размер множества - пустое множество
        capacity = 10; // Начальная емкость массива
        elements = new int[capacity]; // Выделение памяти под массив
        if (!elements) 
        { // Проверка успешности выделения памяти
            cerr << "Ошибка выделения памяти!" << endl;
            exit(1); // Завершение работы программы при ошибке
        }
    }


    /**
 * @brief Конструктор для инициализации множества из массива элементов.
 *
 * Алгоритм:
 * 1. Устанавливает размер множества (size) равным количеству элементов (count).
 * 2. Задает начальную емкость массива (capacity) равной удвоенному количеству элементов.
 * 3. Выделяет память под массив `elements` для хранения элементов.
 * 4. Проверяет успешность выделения памяти. В случае ошибки завершает программу.
 * 5. Копирует элементы из переданного массива `elems` в массив `elements`.
 * 6. Сортирует элементы множества с использованием алгоритма Timsort.
 *
 * @param elems Массив исходных элементов.
 * @param count Количество элементов в массиве.
 */
    MultiSet(const int* elems, size_t count) {
        size = count; // Устанавливаем размер множества
        capacity = count * 2; // Устанавливаем емкость массива с запасом
        elements = new int[capacity]; // Выделяем память под массив элементов
        if (!elements) { // Проверка успешности выделения памяти
            cerr << "Ошибка выделения памяти!" << endl;
            exit(1); // Завершаем выполнение программы при ошибке
        }

        // Копируем элементы из переданного массива
        for (size_t i = 0; i < count; ++i) {
            elements[i] = elems[i];
        }

        // Сортируем элементы множества
        timsort();
    }



    /**
 * @brief Конструктор копирования для создания нового объекта MultiSet из существующего.
 *
 * Конструктор копирования создает новый объект, копируя данные из другого объекта `MultiSet`.
 * Он обеспечивает корректное выделение памяти для массива `elements` и копирует все элементы
 * из исходного множества. Также производится проверка целостности исходного множества.
 *
 * @param other Объект `MultiSet`, из которого копируются данные.
 *
 * @note Если размер множества `other.size` превышает его емкость `other.capacity`, программа
 *       завершается с сообщением об ошибке, поскольку это нарушение инвариантов множества.
 * @note Если не удается выделить память для массива `elements`, программа завершает выполнение
 *       с сообщением об ошибке.
 */
    MultiSet(const MultiSet& other) {
        if (other.size > other.capacity) {
            cerr << "Ошибка: размер множества превышает емкость!" << endl;
            exit(1); // Завершаем выполнение программы
        }

        // Копируем текущий размер множества
        size = other.size;

        // Копируем емкость массива
        capacity = other.capacity;

        // Выделяем память для нового массива элементов
        elements = new int[capacity];
        if (!elements) { // Проверяем успешность выделения памяти
            cerr << "Ошибка выделения памяти!" << endl;
            exit(1); // Завершаем выполнение программы при ошибке
        }

        // Копируем элементы из существующего множества
        for (size_t i = 0; i < size; ++i) {
            elements[i] = other.elements[i];
        }
    }



    ~MultiSet() {
        delete[] elements;
    }

   
    /**
 * @brief Оператор присваивания для объекта MultiSet.
 *
 * Выполняет глубокое копирование данных из другого объекта `MultiSet` в текущий объект.
 * Предварительно освобождает старую память и выделяет новую, чтобы предотвратить утечку памяти.
 *
 * @param other Объект `MultiSet`, данные которого копируются.
 * @return Ссылку на текущий объект `MultiSet` после присваивания.
 *
 * @note Если `other.size` превышает `other.capacity`, программа завершается с ошибкой.
 * @note Если `this` и `other` указывают на один и тот же объект, операция не выполняется.
 */
    MultiSet& operator=(const MultiSet& other) 
    {
        // Проверка на самоприсваивание
        if (this != &other) 
        {
            if (other.size > other.capacity) 
            {
                cerr << "Ошибка: размер множества превышает емкость!" << endl;
                exit(1); // Завершаем выполнение программы
            }

            // Освобождаем старую память
            delete[] elements;

            // Выделяем новую память для элементов
            elements = new int[other.capacity];
            if (!elements) 
            { // Проверяем успешность выделения памяти
                cerr << "Ошибка выделения памяти!" << endl;
                exit(1); // Завершаем выполнение программы при ошибке
            }

            // Копируем параметры
            size = other.size;       // Копируем текущий размер множества
            capacity = other.capacity; // Копируем емкость массива

            // Копируем элементы
            for (size_t i = 0; i < size; ++i) {
                elements[i] = other.elements[i];
            }
        }

        // Возвращаем текущий объект
        return *this;
    }




    /**
 * @brief Добавляет новый элемент в множество и поддерживает его упорядоченность.
 *
 * Алгоритм:
 * 1. Проверяет, достаточно ли емкости массива для добавления нового элемента
 *    (вызов `ensure_capacity()`).
 * 2. Добавляет элемент в конец массива и увеличивает размер множества (`size++`).
 * 3. Сортирует множество (вызов `timsort()`), чтобы сохранить упорядоченность.
 *
 * @param value Значение, которое нужно добавить в множество.
 */
    void add(int value)
    {
        // Убедиться, что есть место для нового элемента
        ensure_capacity();

        // Добавить элемент в конец массива
        elements[size++] = value;

        // Отсортировать множество после добавления
        timsort();
    }




    /**
  * @brief Объединяет текущее множество с другим, формируя новое множество.
  *
  * Алгоритм:
  * 1. Подсчитывает частоты элементов в текущем (`*this`) и другом (`other`) множествах
  *    с помощью метода `count_frequencies`.
  * 2. Определяет максимальную частоту для каждого элемента среди двух множеств.
  * 3. Создает новое множество, добавляя в него элементы с максимальной частотой.
  *
  * @param other Множество, с которым выполняется операция объединения.
  * @return MultiSet Результирующее множество, представляющее объединение.
  */
    MultiSet operator+(const MultiSet& other) const 
    {
        // Массивы для хранения частот элементов двух множеств
        int freq1[1000] = { 0 }, freq2[1000] = { 0 };
        int max_elem1 = 0, max_elem2 = 0;

        // Подсчет частот для текущего множества и другого
        count_frequencies(freq1, max_elem1);
        other.count_frequencies(freq2, max_elem2);

        // Определение максимального элемента среди обоих множеств
        int max_elem = (max_elem1 > max_elem2 ? max_elem1 : max_elem2);
        MultiSet result;

        // Формирование нового множества на основе максимальных частот
        for (int i = 1; i <= max_elem; ++i)
        {
            int count = (freq1[i] > freq2[i] ? freq1[i] : freq2[i]);
            for (int j = 0; j < count; ++j)
            {
                result.add(i);
            }
        }

        return result; // Возвращаем результирующее множество
    }




    /**
  * @brief Выполняет пересечение текущего множества с другим, формируя новое множество.
  *
  * Алгоритм:
  * 1. Подсчитывает частоты элементов в текущем (`*this`) и другом (`other`) множествах
  *    с помощью метода `count_frequencies`.
  * 2. Определяет минимальную частоту для каждого элемента среди двух множеств.
  * 3. Создает новое множество, добавляя в него элементы с минимальной частотой.
  *
  * @param other Множество, с которым выполняется операция пересечения.
  * @return MultiSet Результирующее множество, представляющее пересечение.
  */
    MultiSet operator*(const MultiSet& other) const 
    {
        // Массивы для хранения частот элементов двух множеств
        int freq1[1000] = { 0 }, freq2[1000] = { 0 };
        int max_elem1 = 0, max_elem2 = 0;

        // Подсчет частот для текущего множества и другого
        count_frequencies(freq1, max_elem1);
        other.count_frequencies(freq2, max_elem2);

        // Определение максимального элемента среди обоих множеств
        int max_elem = (max_elem1 > max_elem2 ? max_elem1 : max_elem2);
        MultiSet result;

        // Формирование нового множества на основе минимальных частот
        for (int i = 1; i <= max_elem; ++i) 
        {
            int count = (freq1[i] < freq2[i] ? freq1[i] : freq2[i]);
            for (int j = 0; j < count; ++j)
            {
                result.add(i);
            }
        }

        return result; // Возвращаем результирующее множество
    }


    /**
 * @brief Выполняет вычитание одного множества из другого, формируя новое множество.
 *
 * Алгоритм:
 * 1. Подсчитывает частоты элементов в текущем (`*this`) и другом (`other`) множествах
 *    с помощью метода `count_frequencies`.
 * 2. Для каждого элемента вычисляется разница частот: count = freq1[i] - freq2[i].
 * 3. Если разница больше нуля, то этот элемент добавляется в результирующее множество.
 *
 * @param other Множество, которое вычитается из текущего множества.
 * @return MultiSet Результирующее множество, представляющее разность двух множеств.
 */
    MultiSet operator-(const MultiSet& other) const 
    {
        // Массивы для хранения частот элементов двух множеств
        int freq1[1000] = { 0 }, freq2[1000] = { 0 };
        int max_elem1 = 0, max_elem2 = 0;

        // Подсчет частот для текущего множества и другого
        count_frequencies(freq1, max_elem1);
        other.count_frequencies(freq2, max_elem2);

        // Определение максимального элемента среди обоих множеств
        int max_elem = max(max_elem1, max_elem2);
        MultiSet result;

        // Формирование нового множества, вычитая элементы второго множества из первого
        for (int i = 1; i <= max_elem; ++i)
        {
            int count = freq1[i] - freq2[i];
            if (count > 0) 
            { // Если после вычитания остались элементы, добавляем их в результат
                for (int j = 0; j < count; ++j)
                {
                    result.add(i);
                }
            }
        }

        return result; // Возвращаем результирующее множество
    }


    /**
 * @brief Выполняет операцию симметрической разности двух множеств.
 *
 * Симметрическая разность включает все элементы, которые присутствуют
 * в одном из множеств, но не в обоих одновременно.
 * Алгоритм:
 * 1. Сначала выполняется объединение двух множеств: (*this + other).
 * 2. Затем вычисляется пересечение двух множеств: (*this * other).
 * 3. Из объединения вычитается пересечение, чтобы получить симметрическую разность.
 *
 * @param other Множество, с которым выполняется операция симметрической разности.
 * @return MultiSet Результат симметрической разности двух множеств.
 */
    MultiSet operator^(const MultiSet& other) const 
    {
        // Операция симметрической разности: объединение минус пересечение
        return (*this + other) - (*this * other);
    }


    size_t getSize() const 
    {
        return size;
    }

    /**
 * @brief Перегрузка оператора [] для доступа к элементам множества по индексу.
 *
 * Оператор проверяет, не выходит ли индекс за пределы множества, и в случае ошибки
 * выводит сообщение об ошибке и завершает программу. Если индекс корректен, возвращается
 * элемент множества по заданному индексу.
 *
 * @param index Индекс элемента, к которому нужно получить доступ.
 * @return int Элемент множества, находящийся по указанному индексу.
 */
    int operator[](size_t index) const 
    {
        // Проверка на выход индекса за пределы множества
        if (index >= size)
        {
            cerr << "Индекс выходит за пределы!" << endl;
            exit(1); // Завершаем программу с кодом ошибки 1
        }
        return elements[index]; // Возвращаем элемент по индексу
    }


    /**
 * @brief Перегрузка оператора == для сравнения двух множеств.
 *
 * Оператор проверяет, имеют ли два множества одинаковый размер и содержат ли они одинаковые элементы.
 * Если множества одинаковы по размеру и элементы совпадают, возвращается true. В противном случае — false.
 *
 * @param other Множество, с которым сравнивается текущее множество.
 * @return bool Результат сравнения: true, если множества одинаковы, и false — если различны.
 */
    bool operator==(const MultiSet& other) const 
    {
        // Сравнение размеров множеств
        if (size != other.size) return false;

        // Сравнение элементов множества по очереди
        for (size_t i = 0; i < size; ++i) 
        {
            if (elements[i] != other.elements[i]) return false;
        }

        return true; // Если все элементы совпали, множества равны
    }


    /**
 * @brief Перегрузка оператора != для сравнения двух множеств на неравенство.
 *
 * Оператор использует уже перегруженный оператор == для проверки равенства двух множеств.
 * Возвращает true, если множества различны, и false, если множества равны.
 *
 * @param other Множество, с которым сравнивается текущее множество.
 * @return bool Результат сравнения: true, если множества разные, и false — если множества равны.
 */
    bool operator!=(const MultiSet& other) const 
    {
        return !(*this == other); // Если множества равны, возвращаем false, иначе true
    }


    /**
  * @brief Добавляет первый пропущенный элемент в множество.
  *
  * Функция ищет наименьшее положительное число, которого нет в множестве, и добавляет его.
  * Она начинается с числа 1 и инкрементирует его до тех пор, пока не найдет первое отсутствующее число.
  * Как только оно найдено, оно добавляется в множество и выполнение функции завершается.
  *
  * @note Время работы этой функции в худшем случае составляет O(n * m), где n — количество элементов в множестве,
  *       а m — минимальное пропущенное число.
  */
    void addFirstMissing() 
    {
        int current = 1;  // Начинаем с числа 1
        while (true) 
        {
            bool found = false;
            // Ищем, есть ли текущее число в множестве
            for (size_t i = 0; i < size; ++i)
            {
                if (elements[i] == current)
                {
                    found = true;  // Число найдено
                    break;
                }
            }
            // Если число не найдено, добавляем его в множество
            if (!found) 
            {
                add(current);
                break;
            }
            ++current;  // Переходим к следующему числу
        }
    }


    // Итератор
    class Iterator 
    {
    private:
        int* ptr;
    public:
        Iterator(int* ptr) : ptr(ptr) {}

        // Операция разыменования
        int& operator*() 
        {
            return *ptr;
        }

        // Операция получения указателя на элемент
        int* operator->() 
        {
            return ptr;
        }

        // Операция инкремента (движение итератора вперед)
        Iterator& operator++() 
        {
            ++ptr;
            return *this;
        }

        // Операция декремента (движение итератора назад)
        Iterator& operator--() 
        {
            --ptr;
            return *this;
        }

        // Операция сравнения
        bool operator!=(const Iterator& other) const 
        {
            return ptr != other.ptr;
        }

        bool operator==(const Iterator& other) const 
        {
            return ptr == other.ptr;
        }
    };

    // Метод для получения итератора на первый элемент
    Iterator begin() 
    {
        return Iterator(elements);
    }

    // Метод для получения итератора на элемент после последнего
    Iterator end() 
    {
        return Iterator(elements + size);
    }

    // Метод для получения итератора на элемент перед первым
    Iterator rbegin() 
    {
        return Iterator(elements + size - 1);
    }

    // Метод для получения итератора на элемент перед первым (по аналогии с end для обычных итераторов)
    Iterator rend() 
    {
        return Iterator(elements - 1);
    }

    /**
  * @brief Перегрузка оператора вывода для множества.
  *
  * Функция позволяет вывести содержимое объекта типа MultiSet в поток вывода.
  * Элементы множества выводятся внутри фигурных скобок `{}`, разделенные пробелами.
  *
  * @param os Поток вывода, в который будет записано множество.
  * @param ms Объект множества, содержимое которого будет выведено.
  *
  * @return os Обновленный поток вывода.
  */
    friend ostream& operator<<(ostream& os, const MultiSet& ms) 
    {
        os << "{";
        for (size_t i = 0; i < ms.size; ++i) 
        {
            os << ms.elements[i];  // Выводим текущий элемент множества
            if (i < ms.size - 1) os << " ";  // Добавляем пробел после элемента, если это не последний
        }
        os << "}";
        return os;  // Возвращаем поток для дальнейших операций вывода
    }


    /**
 * @brief Перегрузка оператора ввода для класса MultiSet.
 *
 * Функция позволяет считывать элементы множества из потока ввода в формате:
 * { элемент1 элемент2 ... элементN }
 * Элементы разделяются пробелами, а множество заключено в фигурные скобки `{}`.
 *
 * @param is Поток ввода, из которого считываются данные.
 * @param ms Объект множества, куда записываются считанные элементы.
 *
 * @return is Поток ввода для дальнейших операций.
 *
 * @note Если формат ввода некорректен (например, отсутствуют фигурные скобки или элементы множества
 *       не являются целыми числами), функция выведет сообщение об ошибке и завершит программу.
 */
    friend istream& operator>>(istream& is, MultiSet& ms)
    {
        ms.size = 0;  // Очищаем множество перед вводом новых элементов
        char ch;

        // Считываем открывающую фигурную скобку
        is >> ch;
        if (ch != '{') 
        {
            cerr << "Ввод должен начинаться с '{'" << endl;
            exit(1);
        }

        is >> ws; // Пропускаем пробелы перед первым элементом

        // Если множество пустое
        if (is.peek() == '}') 
        {
            is.get(); // Считываем '}'
            return is; // Возвращаем поток без добавления элементов
        }

        // Считываем элементы множества
        while (true)
        {
            int num;
            is >> num; // Считываем целое число
            ms.add(num); // Добавляем его в множество

            is >> ws; // Пропускаем пробелы перед следующим символом
            char next = is.peek(); // Смотрим на следующий символ

            if (next == '}') 
            { // Если встретили закрывающую скобку
                is.get(); // Считываем '}'
                break; // Завершаем ввод
            }
            else if (!isdigit(next)) 
            {
                // Если следующий символ не число (некорректный ввод)
                cerr << "Ожидался числовой элемент или '}'" << endl;
                exit(1);
            }
        }

        return is; // Возвращаем поток
    }

};

int main() {
    setlocale(LC_ALL, "RUS");
    MultiSet a, b;

    cout << "Введите мультимножество A (в формате {элементы через пробел}): ";
    cin >> a;
    cout << "A" << a << "\n";

    cout << "Введите мультимножество B (в формате {элементы через пробел}): ";
    cin >> b;
    cout << "B" << b << "\n";

    cout << "Объединение A + B: " << (a + b) << "\n";
    cout << "Пересечение A * B: " << (a * b) << "\n";
    cout << "Разность A - B: " << (a - b) << "\n";
    cout << "Симметрическая разность A ^ B: " << (a ^ b) << "\n";

    a.addFirstMissing();
    cout << "A после добавления первого отсутствующего элемента: " << a << "\n";

    // Использование итератора для вывода элементов
    cout << "Элементы множества A: ";
    for (auto it = a.begin(); it != a.end(); ++it) {
        cout << *it << " ";
    }
    cout << "\n";

    return 0;
}